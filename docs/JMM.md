## java内存模型（深入理解java虚拟机第二版 12章）

内存模型：在特定的操作协议下，对特定的内存或者高速缓存进行读写访问的过程抽象。
即数据读写的规则？

### 计算机内存模型
硬件的内存效率和一致性
由于IO操作和cpu操作速度存在很大差异，现代计算机常常加入一层读写速度与接近cpu运算速度的高速缓存来作为内存与处理器之间的缓冲，
将运算需要的数据copy到高速缓存中，让运算能够快速进行，当运算结束后再同步会内存中，这样不再需要缓慢读写，但是却引入缓存一致性
的问题，为了解决这个问题，各个处理器读写数据时往往需要遵循一定的协议。

除此之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码乱序执行优化，然后将结果重组，保证与代码顺序一致，
java虚拟机中也有类似的指令重排序的优化

### java内存模型
为了屏蔽java在各种硬件和操作系统之中内存访问的差异性，以实现java在各个平台运行内存访问的一致性，java规范了一种java内存模型（Java Memory Model）

#### 主内存与工作内存
java内存模型主要目标是定义程序中各个变量的访问规则，即虚拟机中将变量存储到内存和从内存中读取变量的底层细节。
此处的变量包括：实例字段、静态字段和构成的数组，不包括局部变量和方法参数，因为后者是线程私有的。

#### 内存间的交互操作
内存间的交互操作即 从主存中copy到工作内存，从工作内存同步到主存中，java虚拟机定义了8种基本操作类型来完成这些操作，分别是：
1. lock：主内存操作，锁定变量，标识其为线程独占的状态。
2. unlock：主内存操作，解锁变量，将其从线程独占的状态中释放出来。
3. read：主内存操作，读取变量到工作内存。
4. load：工作内存操作，将读取到的变量赋值给工作内存中的变量副本。
5. use：工作内存操作，将变量值传递给执行引擎以供操作。
6. assign：工作内存操作，将执行引擎操作后的值赋给工作内存中的变量。
7. store：工作内存操作，将工作内存中的变量传递给主内存。
8. write：主内存变量，将store得到的值写入主内存中的变量。

对于以上8种内存操作，Java内存模型要求为原子的，不可再分的。读取变量时需要按顺序（非连续）执行read、load，写变量需要按顺序执行store，write，
不过也有特例，对于long和double这种64为的基础数据类型，
在某些平台上，read、load、store、write操作可以拆分成2次32位的操作。这种情况在实际应用中基本不用考虑，因为大部分情况下JVM都会将其当做原子操作处理。

Java内存模型对这8种内存操作定义了以下使用规则：

1. read和load，store和write必须成对出现，即工作内存或主内存必须将已经从另一方读取到的值写入自己所持有的变量，不允许拒绝。
2. 工作内存最后一次assign必须同步回主内存，而工作内存同步回主内存的变量也必须执行过assign操作。
3. 工作内存不可以使用未初始化的变量，即use之前必须要有load，store之前必须要有load和assign。
4. 一个变量只能由一个线程lock，也只能由这个线程unlock，线程可以多次lock，对应的解锁需要同样次数的unlock。
5. 不允许unlock未被lock过的变量，且unlock操作必须在store和write之后。
6. lock unlock ...

#### 对于 volatile 变量的特殊规则 
volatile 变量的两个特性：
- 保证变量对所有线程的可见性
- 防止指令重排序（通过插入内存屏障）

#### 原子性、可见性、有序性
原子性：基本数据类型具备原子性，高级语义通过synchronized实现

可见性：当一个线程修改了共享变量的值，其他线程可以立即知道这个值；
- volatile 每次赋值都会同步到主存，每次使用都会去主存刷新
- 同步块的可见性是由"一个变量执行unlock之前，会执行store、write将变量同步到主存
- final的可见性给予final值不可变

有序性：
在本线程内观察，都是有序的；如果当前线程看其他线程，所有操作都是无序的，因为存在"指令重排序"和"工作内存和主内存的同步延迟"

#### 先行发生规则

1. 程序次序规则。在一个线程内，书写在前面的代码先行发生于后面的。确切地说应该是，按照程序的控制流顺序，因为存在一些分支结构。
2. Volatile变量规则。对一个volatile修饰的变量，对他的写操作先行发生于读操作。
3. 线程启动规则。Thread对象的start()方法先行发生于此线程的每一个动作。
4. 线程终止规则。线程的所有操作都先行发生于对此线程的终止检测。
5. 线程中断规则。对线程interrupt()方法的调用先行发生于被中断线程的代码所检测到的中断事件。
6. 对象终止规则。一个对象的初始化完成（构造函数之行结束）先行发生于发的finilize()方法的开始。
7. 传递性。A先行发生B，B先行发生C，那么，A先行发生C。
8. 管程锁定规则。一个unlock操作先行发生于后面对同一个锁的lock操作。






 

