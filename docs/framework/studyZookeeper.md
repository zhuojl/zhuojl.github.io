#  zookeeper 学习记录

## 写在前面
新公司使用zookeeper进行配置管理，也使用kafka作为主要消息队列，本来是想先看kafka的，结果kafka依赖zookeeper， 故先学习zookeeper！
这篇是是个人总结的内容，不是入门指导，如果萌新佬看到，请转最后引用部分，谢谢！大佬请执教

## 学习目标
- 对zookeeper有全面了解，了解底层核心原理
- 熟悉常用使用场景及底层实现原理
- 运维相关了解

### 核心算法
zookeeper 并不是直接使用的paxos算法（paxos算法 有待更深入的理解），而是使用ZAB协议
- ZAB 协议全称：Zookeeper Atomic Broadcast（Zookeeper 原子广播协议）。
- ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复和原子广播协议。
没有master节点时(刚启动的时候，master节点 down掉的时候)，节点A进入looking状态，向其他节点发起投票请求（aSid, aZxid）（sid：自己服务的id，zxid 节点处理事务的最大的id），
当节点B收到请求时，B可能也发起了投票流程，也可能已经完成了投票，它会依次对比zxid、sid取最大的，如果B的投票对象改变了，则再把结果通知给其他节点

#### zk 的 分布式一致性特性
- 顺序一致性
zk只有一个节点执行请求，所以事务都是顺序执行的
- 原子性
事务通过半数能执行才会执行成功，故障恢复时，也是以最大事务id为主
- 单一视图
外部只有一个视图，zk作为一个整体
- 可靠性/持久性
响应成功，则数据持久存在
- 实时性
有限的时间内的最终一致性

#### zk的设计目标
高性能 - 解决高吞吐量问题
高可用 - 解决单点问题
严格顺序访问能力 - 实现复杂的同步原语

##### 四个设计目标
简单的数据模型（高性能）
提供分布式程序共享的、树状结构的名字空间（内存中以ZNode为数据节点构成的树型数据模型）来相互协调。

构建集群（高可用）
集群中有一半以上的机器能正常工作，就能正常对外服务。
客户端与任一台服务器建立TCP连接，断开后能自动与其他机器建立连接。

顺序访问（严格顺序访问）
对于客户端请求，zk都会分配一个全局递增的事务id,反映事务操作的先后顺序。以此来实现更高层次的同步原语。

高性能
全量数据存在于内存中。适合于多读操作。

#### zk的基本概念

集群角色

会话

版本
version（当前节点版本），cversion（子节点版本），aversion（当前节点的acl版本）

Watcher（事件监听器）

ACL（access control lists）
CREATE、READ、WRITE、DELETE、ADMIN 也就是 增、删、改、查、管理权限，这5种权限简写为crwda(即：每个单词的首字符缩写)
注：这5种权限中，DELETE，CREATE是指对子节点的删除权限

#### 数据节点类型
持久节点、临时节点、顺序节点；

持久节点    ： 持久存在
顺序持久节点 ：在节点后增加顺序数字。
临时节点    ：客户端失效，而非tcp连接断开，节点数据删除
顺序临时节点 ：

#### 角色类型
LEADER：
事务请求的唯一调度和处理者，保证集群事务的顺序性

FOLLOWER：ZOOKEEPER 集群状态的跟随者，
- 处理客户端非事务请求，并转发给Leader节点
- 参与事务请求的投票
- 参与Leader选举

Observer：
通FOLLOWER，只不过不参与投票，只用于提升系统读性能

### 常用场景及原理
核心原理有：
    1. zookeeper可以给节点添加监听器，当某个节点的新增、编辑、删除、增减子节点时都会触发通事件通知
    2. zookeeper具有分布式一致性的特性，如果路径已经创建，第二个创建肯定不成功（只有master对外提供服务，感觉是好控制的）

- 数据发布与订阅 即常用的配置中心，
依靠的是(1)，配合watcher变更配置
- 命名服务，要求全局唯一名称
顺序节点
- 集群管理
临时节点+watcher
- master选举
依靠（2），谁先注册上，谁就是master
- 分布式锁
依靠（2）

### 运维
常用命令。

## 缺点
[知乎](https://www.zhihu.com/question/42931473)

## 写在后面


## 参考
《从PAXOS到zookeeper分布式一致性原理与实践》
[别人的总结](https://juejin.im/post/5c989f6e5188252d785f2333)