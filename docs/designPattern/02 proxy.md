### 代理模式
```
在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。
在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。
```
代理模式是随处可见的设计模式，spring的aop动态代理，mybatis插件增强的动态代理，以及各种静态proxy。

#### 实际应用（源码中、业务中）

- 源码 feign.hystrix.HystrixDelegatingContract
- 老代码逻辑复杂，当某些参数符合一定条件时，全部/部分转发新的处理上。通常可以新增加一个代理做逻辑判断，分别转发到对应的实现上。

#### 解决什么问题
解决对目标对象，接口，增加额外控制等问题，
#### 优缺点
优点： 1、职责清晰。 2、高扩展性。 3、智能化。

缺点： 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。  
 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。

#### 注意事项
1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。  
2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制？？ 我理解是 结构一致，更多在于作用不同，装饰在于包装，增加某种行为；  
代理更多是做一些其他的逻辑判断。

#### 优化实践

项目中有数据归档，在查询时需要拆分参数，重组城每个查询的条件，在之前的实现里，有常规参数处理，还有个分页的处理，分页会继承常规参数处理，并利用
父类的参数处理。后续增加了特殊处理需求，需要增加参数处理实现，相应的分页处理也必须要继承新的实现，全部成对出现。优化方式就是使用代理模式（感觉更多是 组合优于继承），
将分页处理持有参数处理的对象，使用继承方法的地方，改为使用持有对象的方法。

#### demo
太常用，略


#### 引用

- [菜鸟教程](https://www.runoob.com/design-pattern/chain-of-responsibility-pattern.html)