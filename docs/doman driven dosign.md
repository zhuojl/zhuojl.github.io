## 《领域驱动设计》学习记录
《领域驱动设计》这本书经常能在各个地方看到推荐，机缘下也拿到一本，之前经尝试看过两次，
都只看到第二部分，这一次看到第三部分，暂不继续看，因为有些地方感觉有些难懂，
有时候感觉牵强、莫名其妙，也许是经验不足吧，等开工了找更有经验的同事再沟通一下。
以下内容，几乎都是书的一些摘抄。

### 第一部分 运用领域模型

#### 第一章 消化知识
有效建模的几个要素：模型和实现的绑定、建立了一种基于模型的语言、开发一个蕴含丰富知识的模型、
提炼模型、头脑风暴和实验，并强调知识消化、持续学习、知识丰富的设计，最终我们将得到一些深层模型。

#### 第二章 交流与语言的使用
在团队中使用``通用的语言``进行沟通交流并设计，为不一致的术语做翻译，会削减知识。要避免
包罗万象的图，只表达重要的概念。图的目的是帮助表达和解释模型。代码可以充当设计的细节存储。
书面文档也是必不可少的，任何规模的团队都需要它来提供稳定和共享的交流。但要想编写出能够帮助
团队开发出好软件的书面文档却是一个不小的挑战。文档应作为代码和口头交流的补充。文档应当鲜活并保持更新。
模型需要具有解释性，帮助领域学习方面也具有很大价值。

#### 第一章 绑定模型和实现
任何参与建模的技术人员，不管在项目中的主要职责是什么，都必须花时间了解代码。
任何负责修改代码的人员则必须学会用代码来表达模型。每一个开发人员都必须不同程度地参与模型讨论
并且与领域专家保持联系。参与不同工作的人都必须有意识地通过UBIQUITOUS LANGUAGE与接触代码的人
及时交换关于模型的想法。

#### 其他
模型这种知识形式对知识进行了选择性的简化和有意的结构化。

领域模型并非某种特殊的图，而是这种图所要传达的思想。
它绝不单单是领域专家头脑中的知识，而是对这类知识严格的组织且有选择的抽象。

现状：大部分有才能的开发人员对学习与他们的工作领域有关的知识不感兴趣。

所有项目都会丢失知识。高效率的团队需要有意识地积累知识，并持续学习。

高效的领域建模人员是知识的消化者。他们在大量信息中探寻有用的部分。他们不断尝试各种信息组织方式，
努力寻找对大量信息有意义的简单视图。很多模型在尝试后被放弃或改造。只有找到一组适用于所有细节的抽象概念后，
工作才算成功。这一精华严谨地表示了所发现的最为相关的知识。

### 第二部分 模型驱动设计的构造块
将面向对象领域建模中的一些核心的最佳实践提炼为一组基本的构造块。这一部分主要是消除模型与实际运行的软件
之间的鸿沟。团队一致使用这些标准模式就可以使设计井然有序，并且使团队成员更容易理解彼此的工作。
使用标准模式还可以为公共语言贡献术语，使得所有团队成员可以使用这些术语来讨论模型和设计决策。
但这一部分的主旨是讨论一些能够保持模型和实现之间互相协调并提高效率的设计决策。要想达到这种协调，
需要密切注意个别元素的一些细节。这种小规模的仔细设计为开发人员提供了一个稳固的基础，
在此基础上就可以应用第三部分和第四部分讨论的建模方法了。

#### 第四章 分层架构
现在复杂的项目中基本都是分层架构，ui层，应用层，领域层，基础层。
分层更易理解和维护，层与层之间更易理解和维护，如果下层需要与上层进行通行，可以使用回调模式和
观察者模式。

#### 第五章 软件中所表示的模型 ENTITY、VALUE OBJECT、SERVICE、MODULE，
思考电影院的座位问题以便帮助理解ENTITY和VALUE OBJECT，个人觉得不是那么重要，VALUE OBJECT常是临时对象。
SERVICE和MODULE还是好理解的，日常中常用。

##### SERVICE
好的SERVICE有以下3个特征。
1. 与领域概念相关的操作不是ENTITY或VALUE OBJECT的一个自然组成部分。
2. 接口是根据领域模型的其他元素定义的。
3. 操作是无状态的。这里所说的无状态是指任何客户都可以使用某个SERVICE的任何实例，
而不必关心该实例的历史状态。SERVICE执行时将使用可全局访问的信息，
甚至会更改这些全局信息(也就是说，它可能具有副作用)。但SERVICE不保持影响其自身行为的状态，
这一点与大多数领域对象不同。

当领域中的某个重要的过程或转换操作不是ENTITY或VALUE OBJECT的自然职责时，
应该在模型中添加一个作为独立接口的操作，并将其声明为SERVICE。

##### MODULE
MODULE是一个传统的、较成熟的设计元素。虽然使用模块有一些技术上的原因，但主要原因却是``认知超载``。
MODULE为人们提供了两种观察模型的方式，一是可以在MODULE中查看细节，而不会被整个模型淹没，
二是观察MODULE之间的关系，而不考虑其内部细节。

认知超载，cognitive overload，认知负荷理论(cognitive load theory)中的一个术语。
问题解决和学习过程中的各种认知加工活动均需消耗认知资源，若所有活动所需的资源总量超过个体拥有的资源总量，
就会引起资源的分配不足，从而影响个体学习或问题解决的效率，这种情况被称为认知超载。

#### 第六章 领域对象的生命周期 AGGREGATE、FACTORY、REPOSITORY
我们应该将ENTITY和VALUE OBJECT分门别类地聚集到AGGREGATE中，并定义每个AGGREGATE的边界。
在每个AGGREGATE中，选择一个ENTITY作为根，并通过根来控制对边界内其他对象的所有访问。
只允许外部对象保持对根的引用。对内部成员的临时引用可以被传递出去，但仅在一次操作中有效。
由于根控制访问，因此不能绕过它来修改内部对象。这种设计有利于确保AGGREGATE中的对象满足所有固定规则，
也可以确保在任何状态变化时AGGREGATE作为一个整体满足固定规则。

FACTORY、REPOSITORY太常用的组件，没仔细看。

#### 第七章
例子没仔细看，感觉需求跟不上，他说什么就是什么。。。下次看的时候可以深入看下。

#### 其他
将领域层分离出来才是实现MODEL-DRIVEN DESIGN的关键。

将领域层与基础设施层以及用户界面层分离，可以使每层的设计更加清晰。彼此独立的层更容易维护，
因为它们往往以不同的速度发展并且满足不同的需求。

领域模型是一系列概念的集合。“领域层”则是领域模型以及所有与其直接相关的设计元素的表现，
它由业务逻辑的设计和实现组成。领域实现独立出来是领域驱动设计的前提。

ENTITY最基本的职责是确保连续性，以便使其行为更清楚且可预测。保持实体的简练是实现这一责任的关键。
用于描述领域的某个方面而本身没有概念标识的对象称为VALUE OBJECT(值对象)

### 第三部分 通过重构来加深理解
讨论如何将构造块装配为实用的模型，从而实现其价值。这一部分没有直接讨论深奥的设计原则，
而是着重强调一个发现过程。有价值的模型不是立即就会出现的，它们需要对领域的深入理解。
这种理解是一步一步得到的，首先需要深入研究模型，然后基于最初的(可能是不成熟的)模型实现一个初始设计，
再反复改进这个设计。每次团队对领域有了新的理解之后，都需要对模型进行改进，使模型反映出更丰富的知识，
而且必须对代码进行重构，以便反映出更深刻的模型，并使应用程序可以充分利用模型的潜力。
这种一层一层“剥洋葱”的方法有时会创造一种突破的机会，使我们得到更深刻的模型，
同时快速进行一些更深入的设计修改。

探索本身是永无止境的，但这并不意味着它是随机的。第三部分深入阐述一些指引我们保持正确方向的建模原则，
并提供了一些指导我们进行探索的方法。

#### 第八章 突破
个人的理解是通过不断的知识消化，持续学习，重构而逐渐得到一个深入的理解，这就是深层模型？
突破是``得到更符合用户需要，更加切合实际的模型``这么一个动作。

不要试图去制造突破，那只会使项目陷入困境。通常，只有在实现了许多适度的重构后
才有可能出现突破。在大部分时间里，我们都在进行微小的改进，而在这种连续的改进中模型深层含义也会逐渐显现。
要为突破做好准备，应专注于知识消化过程，同时也要逐渐建立健壮的UBIQUITOUS LANGUAGE。

不要犹豫着不去做小的改进，这些改进即使脱离不开常规的概念框架，也可以逐渐加深我们对模型理解。
不要因为好高骛远而使项目陷入困境。只要随时注意可能出现的机会就够了

#### 第九章 将隐式概念转变为显式概念
深层模型之所以强大是因为它包含了领域的核心概念和抽象，能够以简单灵活的方式表达出基本的用户活动、
问题以及解决方案。深层建模的第一步就是要设法在模型中表达出领域的基本概念。随后，在不断消化知
识和重构的过程中，实现模型的精化。

开发人员必须能够敏锐地捕捉到隐含概念的蛛丝马迹，但有时他们必须主动寻找线索。要``挖掘出大部分的隐含概念``，
需要开发人员去倾听团队语言、仔细检查设计中的不足之处以及与专家观点相矛盾的地方、研究领域相关文献并且进行大量的实验

为不太明显的概念（显式约束、过程(SERVICE)、断言）建模。
##### 约束
下面是一些警告信号，表明约束的存在正在扰乱其“宿主对象”(Host Object)的设计。
1. 计算约束所需的数据从定义上看并不属于这个对象。
2. 相关规则在多个对象中出现，造成了代码重复或导致不属于同一族的对象之间产生了继
承关系。
3. 很多设计和需求讨论是围绕这些约束进行的，而在代码实现中，它们却隐藏在过程代码
中。

如果约束的存在掩盖了对象的基本职责，或者如果约束在领域中非常突出但在模型中却不明显，
那么就可以将其提取到一个显式的对象中，甚至可以把它建模为一个对象和关系的集合。

业务规则通常不适合作为ENTITY或VALUE OBJECT的职责，而且规则的变化和组合也会掩盖领域对象的基本含义。
但是将规则移出领域层的结果会更糟糕，因为这样一来，领域代码就不再表达模型了。

##### 模式:SPECIFICATION
逻辑编程提供了一种概念，即“谓词”这种可分离、可组合的规则对象，但是要把这种概念用对象完全实现是很麻烦的。
同时，这种概念过于通用，在表达设计意图方面，它的针对性不如专门的设计那么好。

SPECIFICATION可以测试任何对象以检验它们是否满足指定的标准。
为特殊目的创建谓词形式的显式的VALUE OBJECT。SPECIFICATION就是一个谓词，可用来确定对象是否满足某些标准。

这些话乌七八糟的让人看不懂，不过通过谓词可以联想一下java8的Predicate，再看上面的话就有些眉目了。

#### 第十章 柔性设计
软件的最终目的是为用户服务。但首先它必须为开发人员服务。开发人员有两个角色，创建者与使用者（维护者）

当具有复杂行为的软件缺乏良好的设计时，重构或元素的组合会变得很困难。一旦开发人员不能十分肯定地预知计算的全部含意，
就会出现重复。当设计元素都是整块的而无法重新组合的时候，重复就是一种必然的结果。我们可以对类和方法进行分解，
这样可以更好地重用它们，但这些小部分的行为又变得很难跟踪。如果软件没有一个条理分明的设计，
那么开发人员不仅不愿意仔细地分析代码，他们更不愿意修改代码，因为修改代码会产生问题——要么加重了代码的混乱状态，
要么由于某种未预料到的依赖而破坏了某些东西。

为了使项目能够随着开发工作的进行加速前进，而不会由于它自己的老化停滞不前，设计必
须要让人们乐于使用，而且易于做出修改。这就是``柔性设计(supple design)``。

当复杂性阻碍了项目的前进时，就需要仔细修改最关键、最复杂的地方，使之变成一个柔性设计(乐于使用，易修改)，
这样才能突破复杂性带给我们的限制，而不会陷入遗留代码维护的麻烦中。

设计这样的软件并没有公式，作者精选了一组模式，从作者的经验来看，这些模式如果运用得当的话，
就有可能获得柔性设计：
- INTENTION-REVEALING INTERFACES（释意接口）所有复杂的机制都应该封装到抽象接口的后面，接口只表明意图，而不表明方式。

- SIDE-EFFECT-FREE FUNCTION（无副作用的函数）简单来说就是：查询与修改分开；用值对象封装无副作用的逻辑。
原书上说：尽可能把程序的逻辑放到函数中，因为函数是只返回结果而不产生明显副作用（在计算机科学中，
任何对系统状态产生的影响都叫副作用）的操作。严格地把命令(引起明显的状态改变的方法)
隔离到不返回领域信息的、非常简单的操作中。当发现了一个非常适合承担复杂逻辑职责的概念时，
就可以把这个复杂逻辑移到VALUE OBJECT中，这样可以进一步控制副作用。

- ASSERTION（断言）感觉没啥用，谁会去assert每个变量呢。

- CONCEPTUAL CONTOUR（概念轮廓）随着代码不断适应新理解的概念或需求，CONCEPTUAL CONTOUR(概念轮廓)
也就逐渐形成了。寻找在概念上有意义的功能单元，这样可以使得设计既灵活又易懂。  ``蒙蔽``。
我的理解就是通过重构或者知识消化等有了新的认识，新的边界划分？？？缺少个例子。

- STANDALONE CLASS（独立的类）尽力把最复杂的计算提取到STANDALONE CLASS(独立的类)中，
实现此目的的一种方法是从存在大量依赖的类中将VALUE OBJECT建模出来。就是提炼工具方法嘛？？？
缺少个例子。

- CLOSURE OF OPERATION（闭合操作）在适当的情况下，在定义操作时让它的返回类型与其参数的类型相同。
如果实现者(implementer)的状态在计算中会被用到，那么实现者实际上就是操作的一个参数，因此参数
和返回值应该与实现者有相同的类型。这样的操作就是在该类型的实例集合中的闭合操作。闭合操作提供了一个高层接口，
同时又不会引入对其他概念的任何依赖。举例：java.math.BigDecimal.add(java.math.BigDecimal)

10.7-10.8 声明式设计 相关略

#### 第十三章 通过重构得到更深层的理解
即使在代码看上去很整洁的时候也可能需要重构，原因是模型的语言没有与领域专家保持一致，
或者新需求不能被自然地添加到模型中。重构的原因也可能来自学习:当开发人员通过学习获得了更深刻的理解，
从而发现了一个得到更清晰或更有用的模型的机会。

软件不仅仅是为用户提供的，也是为开发人员提供的。柔性设计主要通过减少依赖性和副作用来减轻人们的思考负担。

##### 重构的时机
- 设计没有表达出团队对领域的最新理解;
- 重要的概念被隐藏在设计中了(而且你已经发现了把它们呈现出来的方法);
- 发现了一个能令某个重要的设计部分变得更灵活的机会。

我们虽然应该有这样一种积极的态度，但并不意味着可以随随便便做任何修改。在发布的前一天，就不要进行重构了。
不要引入一些只顾炫耀技术能力而没有解决领域核心问题的“柔性设计”。无论一个“更深层的模型”看起来有多好，
如果你不能说服领域专家们去使用它，那么就不要引入它。万事都不是绝对的，但如果某个重构对我们有利，
那么不妨在这个方向上大胆前进。

##### 危机就是机遇
在达尔文创立进化论后的一个多世纪中，人们一直认为标准的进化模型就是物种随着时间缓慢地改变(在一定程度上这种改变是稳定的)。
突然之间，这个模型在20世纪70年代被“间断平衡”(punctuated equilibrium)模型取代了。
它对原有进化论进行了扩展，认为长期的缓慢变化或稳定变化会被相对来说很短的、爆发性的快速变化所打断。
然后事物会进入一个新的平衡。软件开发与物种进化之间的不同点是前者具有明确的方向(虽然在某些项目上可能并不明显)，
尽管如此软件开发仍遵循这种进化规律。


### 第四部分 战略设计

略
